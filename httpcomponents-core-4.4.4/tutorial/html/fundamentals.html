<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;1.&nbsp;Fundamentals</title><link rel="stylesheet" type="text/css" href="css/hc-tutorial.css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"><link rel="home" href="index.html" title="HttpCore Tutorial"><link rel="up" href="index.html" title="HttpCore Tutorial"><link rel="prev" href="preface.html" title="Preface"><link rel="next" href="blocking-io.html" title="Chapter&nbsp;2.&nbsp;Blocking I/O model"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="banner"><a class="bannerLeft" href="http://www.apache.org/" title="Apache Software Foundation"><img style="border:none;" src="images/asf_logo_wide.gif"></a><a class="bannerRight" href="http://hc.apache.org/httpcomponents-core-ga/" title="Apache HttpComponents Core"><img style="border:none;" src="images/hc_logo.png"></a><div class="clear"></div></div><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;1.&nbsp;Fundamentals</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="preface.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="blocking-io.html">Next</a></td></tr></table><hr></div><div class="chapter" title="Chapter&nbsp;1.&nbsp;Fundamentals"><div class="titlepage"><div><div><h2 class="title"><a name="fundamentals"></a>Chapter&nbsp;1.&nbsp;Fundamentals</h2></div></div></div>
    
    <div class="section" title="1.1.&nbsp;HTTP messages"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e48"></a>1.1.&nbsp;HTTP messages</h2></div></div></div>
        
        <div class="section" title="1.1.1.&nbsp;Structure"><div class="titlepage"><div><div><h3 class="title"><a name="d5e50"></a>1.1.1.&nbsp;Structure</h3></div></div></div>
            
            <p>
            A HTTP message consists of a header and an optional body. The message header of an HTTP
            request consists of a request line and a collection of header fields. The message header
            of an HTTP response consists of a status line and a collection of header fields. All
            HTTP messages must include the protocol version. Some HTTP messages can optionally
            enclose a content body.
            </p>
            <p>
            HttpCore defines the HTTP message object model to follow this definition closely, and
            provides extensive support for serialization (formatting) and deserialization
            (parsing) of HTTP message elements.
            </p>
        </div>
        <div class="section" title="1.1.2.&nbsp;Basic operations"><div class="titlepage"><div><div><h3 class="title"><a name="d5e54"></a>1.1.2.&nbsp;Basic operations</h3></div></div></div>
            
            <div class="section" title="1.1.2.1.&nbsp;HTTP request message"><div class="titlepage"><div><div><h4 class="title"><a name="d5e56"></a>1.1.2.1.&nbsp;HTTP request message</h4></div></div></div>
                
                <p>
                HTTP request is a message sent from the client to the server. The first line of
                that message includes the method to apply to the resource, the identifier of
                the resource, and the protocol version in use.
                </p>
                <pre class="programlisting">
HttpRequest request = new BasicHttpRequest("GET", "/",
    HttpVersion.HTTP_1_1);

System.out.println(request.getRequestLine().getMethod());
System.out.println(request.getRequestLine().getUri());
System.out.println(request.getProtocolVersion());
System.out.println(request.getRequestLine().toString());
</pre>
                <p>stdout &gt;</p>
                <pre class="programlisting">
GET
/
HTTP/1.1
GET / HTTP/1.1
</pre>
            </div>
            <div class="section" title="1.1.2.2.&nbsp;HTTP response message"><div class="titlepage"><div><div><h4 class="title"><a name="d5e62"></a>1.1.2.2.&nbsp;HTTP response message</h4></div></div></div>
                
                <p>
                HTTP response is a message sent by the server back to the client after having
                received and interpreted a request message. The first line of that message
                consists of the protocol version followed by a numeric status code and its
                associated textual phrase.
                </p>
                <pre class="programlisting">
HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1,
    HttpStatus.SC_OK, "OK");

System.out.println(response.getProtocolVersion());
System.out.println(response.getStatusLine().getStatusCode());
System.out.println(response.getStatusLine().getReasonPhrase());
System.out.println(response.getStatusLine().toString());
</pre>
                <p>stdout &gt;</p>
                <pre class="programlisting">
HTTP/1.1
200
OK
HTTP/1.1 200 OK
</pre>
            </div>
            <div class="section" title="1.1.2.3.&nbsp;HTTP message common properties and methods"><div class="titlepage"><div><div><h4 class="title"><a name="d5e68"></a>1.1.2.3.&nbsp;HTTP message common properties and methods</h4></div></div></div>
                
                <p>
                An HTTP message can contain a number of headers describing properties of the
                message such as the content length, content type, and so on. HttpCore provides
                methods to retrieve, add, remove, and enumerate such headers.
                </p>
                <pre class="programlisting">
HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1,
    HttpStatus.SC_OK, "OK");
response.addHeader("Set-Cookie",
    "c1=a; path=/; domain=localhost");
response.addHeader("Set-Cookie",
    "c2=b; path=\"/\", c3=c; domain=\"localhost\"");
Header h1 = response.getFirstHeader("Set-Cookie");
System.out.println(h1);
Header h2 = response.getLastHeader("Set-Cookie");
System.out.println(h2);
Header[] hs = response.getHeaders("Set-Cookie");
System.out.println(hs.length);
</pre>
                <p>stdout &gt;</p>
                <pre class="programlisting">
Set-Cookie: c1=a; path=/; domain=localhost
Set-Cookie: c2=b; path="/", c3=c; domain="localhost"
2
</pre>
                <p>
                There is an efficient way to obtain all headers of a given type using the
                <code class="interfacename">HeaderIterator</code> interface.
                </p>
                <pre class="programlisting">
HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1,
    HttpStatus.SC_OK, "OK");
response.addHeader("Set-Cookie",
    "c1=a; path=/; domain=localhost");
response.addHeader("Set-Cookie",
    "c2=b; path=\"/\", c3=c; domain=\"localhost\"");

HeaderIterator it = response.headerIterator("Set-Cookie");

while (it.hasNext()) {
    System.out.println(it.next());
}
</pre>
                <p>stdout &gt;</p>
                <pre class="programlisting">
Set-Cookie: c1=a; path=/; domain=localhost
Set-Cookie: c2=b; path="/", c3=c; domain="localhost"
</pre>
                <p>
                It also provides convenience methods to parse HTTP messages into individual
                header elements.
                </p>
                <pre class="programlisting">
HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1,
    HttpStatus.SC_OK, "OK");
response.addHeader("Set-Cookie",
    "c1=a; path=/; domain=localhost");
response.addHeader("Set-Cookie",
    "c2=b; path=\"/\", c3=c; domain=\"localhost\"");

HeaderElementIterator it = new BasicHeaderElementIterator(
        response.headerIterator("Set-Cookie"));

while (it.hasNext()) {
    HeaderElement elem = it.nextElement();
    System.out.println(elem.getName() + " = " + elem.getValue());
    NameValuePair[] params = elem.getParameters();
    for (int i = 0; i &lt; params.length; i++) {
        System.out.println(" " + params[i]);
    }
}
</pre>
                <p>stdout &gt;</p>
                <pre class="programlisting">
c1 = a
 path=/
 domain=localhost
c2 = b
 path=/
c3 = c
 domain=localhost
</pre>
                <p>
                HTTP headers are tokenized into individual header elements only on demand. HTTP
                headers received over an HTTP connection are stored internally as an array of
                characters and parsed lazily only when you access their properties.
                </p>
            </div>
        </div>
        <div class="section" title="1.1.3.&nbsp;HTTP entity"><div class="titlepage"><div><div><h3 class="title"><a name="d5e84"></a>1.1.3.&nbsp;HTTP entity</h3></div></div></div>
            
            <p>
            HTTP messages can carry a content entity associated with the request or response.
            Entities can be found in some requests and in some responses, as they are optional.
            Requests that use entities are referred to as entity-enclosing requests. The HTTP
            specification defines two entity-enclosing methods: POST and PUT. Responses are
            usually expected to enclose a content entity. There are exceptions to this rule such
            as responses to HEAD method and 204 No Content, 304 Not Modified, 205 Reset Content
            responses.
            </p>
            <p>
            HttpCore distinguishes three kinds of entities, depending on where their content
            originates:
            </p>
            <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                    <p title="streamed:">
                    <b>streamed:&nbsp;</b>
                    
                    The content is received from a stream, or generated on the fly. In particular,
                    this category includes entities being received from a connection. Streamed
                    entities are generally not repeatable.
                    
                    </p>
                </li><li class="listitem">
                    <p title="self-contained:">
                    <b>self-contained:&nbsp;</b>
                    
                    The content is in memory or obtained by means that are independent from
                    a connection or other entity. Self-contained entities are generally repeatable.
                    
                    </p>
                </li><li class="listitem">
                    <p title="wrapping:">
                    <b>wrapping:&nbsp;</b>
                    
                    The content is obtained from another entity.
                    
                    </p>
                </li></ul></div>
            <div class="section" title="1.1.3.1.&nbsp;Repeatable entities"><div class="titlepage"><div><div><h4 class="title"><a name="d5e101"></a>1.1.3.1.&nbsp;Repeatable entities</h4></div></div></div>
                
                <p>
                An entity can be repeatable, meaning its content can be read more than once. This
                is only possible with self-contained entities (like
                <code class="classname">ByteArrayEntity</code> or <code class="classname">StringEntity</code>).
                </p>
            </div>
            <div class="section" title="1.1.3.2.&nbsp;Using HTTP entities"><div class="titlepage"><div><div><h4 class="title"><a name="d5e106"></a>1.1.3.2.&nbsp;Using HTTP entities</h4></div></div></div>
                
                <p>
                Since an entity can represent both binary and character content, it has support
                for character encodings (to support the latter, i.e. character content).
                </p>
                <p>
                The entity is created when executing a request with enclosed content or when the
                request was successful and the response body is used to send the result back to
                the client.
                </p>
                <p>
                To read the content from the entity, one can either retrieve the input stream via
                the <code class="methodname">HttpEntity#getContent()</code> method, which returns an
                <code class="classname">java.io.InputStream</code>, or one can supply an output stream to
                the <code class="methodname">HttpEntity#writeTo(OutputStream)</code> method, which will
                return once all content has been written to the given stream. Please note that
                some non-streaming (self-contained) entities may be unable to represent their
                content as a <code class="classname">java.io.InputStream</code> efficiently. It is legal
                for such entities to implement <code class="methodname">HttpEntity#writeTo(OutputStream)
                </code> method only and to throw <code class="classname">UnsupportedOperationException
                </code> from <code class="methodname">HttpEntity#getContent()</code> method.
                </p>
                <p>
                The <code class="classname">EntityUtils</code> class exposes several static methods to simplify 
                extracting the content or information from an entity. Instead of reading
                the <code class="classname">java.io.InputStream</code> directly, one can retrieve the complete
                content body in a string or byte array by using the methods from this class.
                </p>
                <p>
                When the entity has been received with an incoming message, the methods
                <code class="methodname">HttpEntity#getContentType()</code> and
                <code class="methodname">HttpEntity#getContentLength()</code> methods can be used for
                reading the common metadata such as <code class="literal">Content-Type</code> and
                <code class="literal">Content-Length</code> headers (if they are available). Since the
                <code class="literal">Content-Type</code> header can contain a character encoding for text
                mime-types like <code class="literal">text/plain</code> or <code class="literal">text/html</code>,
                the <code class="methodname">HttpEntity#getContentEncoding()</code> method is used to
                read this information. If the headers aren't available, a length of -1 will be
                returned, and <code class="literal">NULL</code> for the content type. If the
                <code class="literal">Content-Type</code> header is available, a Header object will be
                returned.
                </p>
                <p>
                When creating an entity for a outgoing message, this meta data has to be supplied
                by the creator of the entity.
                </p>
                <pre class="programlisting">
StringEntity myEntity = new StringEntity("important message",
    Consts.UTF_8);

System.out.println(myEntity.getContentType());
System.out.println(myEntity.getContentLength());
System.out.println(EntityUtils.toString(myEntity));
System.out.println(EntityUtils.toByteArray(myEntity).length);
</pre>
                <p>stdout &gt;</p>
                <pre class="programlisting">
Content-Type: text/plain; charset=UTF-8
17
important message
17
</pre>
            </div>
            <div class="section" title="1.1.3.3.&nbsp;Ensuring release of system resources"><div class="titlepage"><div><div><h4 class="title"><a name="d5e136"></a>1.1.3.3.&nbsp;Ensuring release of system resources</h4></div></div></div>
                
                <p>
                In order to ensure proper release of system resources one must close the content
                stream associated with the entity.
                </p>
                <pre class="programlisting">
HttpResponse response;
HttpEntity entity = response.getEntity();
if (entity != null) {
    InputStream instream = entity.getContent();
    try {
        // do something useful
    } finally {
        instream.close();
    }
}
</pre>
                <p>
                When working with streaming entities, one can use the
                <code class="methodname">EntityUtils#consume(HttpEntity)</code> method to ensure that
                the entity content has been fully consumed and the underlying stream has been
                closed.
                </p>
            </div>
        </div>
        <div class="section" title="1.1.4.&nbsp;Creating entities"><div class="titlepage"><div><div><h3 class="title"><a name="d5e142"></a>1.1.4.&nbsp;Creating entities</h3></div></div></div>
            
            <p>
            There are a few ways to create entities. HttpCore provides the following implementations:
            </p>
            <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                    <p>
                        <a class="link" href="fundamentals.html#basic-entity" title="1.1.4.1.&nbsp;BasicHttpEntity">
                            <code class="classname">BasicHttpEntity</code>
                        </a>
                    </p>
                </li><li class="listitem">
                    <p>
                        <a class="link" href="fundamentals.html#byte-array-entity" title="1.1.4.2.&nbsp;ByteArrayEntity">
                            <code class="classname">ByteArrayEntity</code>
                        </a>
                    </p>
                </li><li class="listitem">
                    <p>
                        <a class="link" href="fundamentals.html#string-entity" title="1.1.4.3.&nbsp;StringEntity">
                            <code class="classname">StringEntity</code>
                        </a>
                    </p>
                </li><li class="listitem">
                    <p>
                        <a class="link" href="fundamentals.html#input-stream-entity" title="1.1.4.4.&nbsp;InputStreamEntity">
                            <code class="classname">InputStreamEntity</code>
                        </a>
                    </p>
                </li><li class="listitem">
                    <p>
                        <a class="link" href="fundamentals.html#file-entity" title="1.1.4.5.&nbsp;FileEntity">
                            <code class="classname">FileEntity</code>
                        </a>
                    </p>
                </li><li class="listitem">
                    <p>
                        <a class="link" href="">
                            <code class="classname">EntityTemplate</code>
                        </a>
                    </p>
                </li><li class="listitem">
                    <p>
                        <a class="link" href="fundamentals.html#entity-wrapper" title="1.1.4.6.&nbsp;HttpEntityWrapper">
                            <code class="classname">HttpEntityWrapper</code>
                        </a>
                    </p>
                </li><li class="listitem">
                    <p>
                        <a class="link" href="fundamentals.html#buffered-entity" title="1.1.4.7.&nbsp;BufferedHttpEntity">
                            <code class="classname">BufferedHttpEntity</code>
                        </a>
                    </p>
                </li></ul></div>
            <div class="section" title="1.1.4.1.&nbsp;BasicHttpEntity"><div class="titlepage"><div><div><h4 class="title"><a name="basic-entity"></a>1.1.4.1.&nbsp;<code class="classname">BasicHttpEntity</code></h4></div></div></div>
                
                <p>
                Exactly as the name implies, this basic entity represents an underlying stream.
                In general, use this class for entities received from HTTP messages.
                </p>
                <p>
                This entity has an empty constructor. After construction, it represents no content,
                and has a negative content length.
                </p>
                <p>
                One needs to set the content stream, and optionally the length. This can be done
                with the <code class="methodname">BasicHttpEntity#setContent(InputStream)</code> and
                <code class="methodname">BasicHttpEntity#setContentLength(long)</code> methods
                respectively.
                </p>
                <pre class="programlisting">
BasicHttpEntity myEntity = new BasicHttpEntity();
myEntity.setContent(someInputStream);
myEntity.setContentLength(340); // sets the length to 340
</pre>
            </div>
            <div class="section" title="1.1.4.2.&nbsp;ByteArrayEntity"><div class="titlepage"><div><div><h4 class="title"><a name="byte-array-entity"></a>1.1.4.2.&nbsp;<code class="classname">ByteArrayEntity</code></h4></div></div></div>
                
                <p>
                <code class="classname">ByteArrayEntity</code> is a self-contained, repeatable entity
                that obtains its content from a given byte array. Supply the byte array to the
                constructor.
                </p>
                <pre class="programlisting">
ByteArrayEntity myEntity = new ByteArrayEntity(new byte[] {1,2,3},
        ContentType.APPLICATION_OCTET_STREAM);
</pre>
            </div>
            <div class="section" title="1.1.4.3.&nbsp;StringEntity"><div class="titlepage"><div><div><h4 class="title"><a name="string-entity"></a>1.1.4.3.&nbsp;<code class="classname">StringEntity</code></h4></div></div></div>
                
                <p>
                <code class="classname">StringEntity</code> is a self-contained, repeatable entity that
                obtains its content from a <code class="classname">java.lang.String</code> object. It has
                three constructors, one simply constructs with a given <code class="classname">java.lang.String
                </code> object; the second also takes a character encoding for the data in the
                string; the third allows the mime type to be specified.
                </p>
                <pre class="programlisting">
StringBuilder sb = new StringBuilder();
Map&lt;String, String&gt; env = System.getenv();
for (Map.Entry&lt;String, String&gt; envEntry : env.entrySet()) {
    sb.append(envEntry.getKey())
            .append(": ").append(envEntry.getValue())
            .append("\r\n");
}

// construct without a character encoding (defaults to ISO-8859-1)
HttpEntity myEntity1 = new StringEntity(sb.toString());

// alternatively construct with an encoding (mime type defaults to "text/plain")
HttpEntity myEntity2 = new StringEntity(sb.toString(), Consts.UTF_8);

// alternatively construct with an encoding and a mime type
HttpEntity myEntity3 = new StringEntity(sb.toString(),
        ContentType.create("text/plain", Consts.UTF_8));
</pre>
            </div>
            <div class="section" title="1.1.4.4.&nbsp;InputStreamEntity"><div class="titlepage"><div><div><h4 class="title"><a name="input-stream-entity"></a>1.1.4.4.&nbsp;<code class="classname">InputStreamEntity</code></h4></div></div></div>
                
                <p>
                <code class="classname">InputStreamEntity</code> is a streamed, non-repeatable entity that
                obtains its content from an input stream. Construct it by supplying the input
                stream and the content length. Use the content length to limit the amount of data
                read from the <code class="classname">java.io.InputStream</code>. If the length matches
                the content length available on the input stream, then all data will be sent.
                Alternatively, a negative content length will read all data from the input stream,
                which is the same as supplying the exact content length, so use the length to limit
                the amount of data to read.
                </p>
                <pre class="programlisting">
InputStream instream = getSomeInputStream();
InputStreamEntity myEntity = new InputStreamEntity(instream, 16);
</pre>
            </div>
            <div class="section" title="1.1.4.5.&nbsp;FileEntity"><div class="titlepage"><div><div><h4 class="title"><a name="file-entity"></a>1.1.4.5.&nbsp;<code class="classname">FileEntity</code></h4></div></div></div>
                
                <p>
                <code class="classname">FileEntity</code> is a self-contained, repeatable entity that
                obtains its content from a file. Use this mostly to stream large files of different
                types, where you need to supply the content type of the file, for
                instance, sending a zip file would require the content type <code class="literal">
                application/zip</code>, for XML <code class="literal">application/xml</code>.
                </p>
                <pre class="programlisting">
HttpEntity entity = new FileEntity(staticFile,
        ContentType.create("application/java-archive"));
</pre>
            </div>
            <div class="section" title="1.1.4.6.&nbsp;HttpEntityWrapper"><div class="titlepage"><div><div><h4 class="title"><a name="entity-wrapper"></a>1.1.4.6.&nbsp;<code class="classname">HttpEntityWrapper</code></h4></div></div></div>
                
                <p>
                This is the base class for creating wrapped entities. The wrapping entity holds
                a reference to a wrapped entity and delegates all calls to it. Implementations
                of wrapping entities can derive from this class and need to override only those
                methods that should not be delegated to the wrapped entity.
                </p>
            </div>
            <div class="section" title="1.1.4.7.&nbsp;BufferedHttpEntity"><div class="titlepage"><div><div><h4 class="title"><a name="buffered-entity"></a>1.1.4.7.&nbsp;<code class="classname">BufferedHttpEntity</code></h4></div></div></div>
                
                <p>
                <code class="classname">BufferedHttpEntity</code> is a subclass of <code class="classname">
                HttpEntityWrapper</code>. Construct it by supplying another entity. It
                reads the content from the supplied entity, and buffers it in memory.
                </p>
                <p>
                This makes it possible to make a repeatable entity, from a non-repeatable entity.
                If the supplied entity is already repeatable, it simply passes calls through to
                the underlying entity.
                </p>
                <pre class="programlisting">
myNonRepeatableEntity.setContent(someInputStream);
BufferedHttpEntity myBufferedEntity = new BufferedHttpEntity(
  myNonRepeatableEntity);
</pre>
            </div>
        </div>
    </div>
    <div class="section" title="1.2.&nbsp;HTTP protocol processors"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e228"></a>1.2.&nbsp;HTTP protocol processors</h2></div></div></div>
        
        <p>
        HTTP protocol interceptor is a routine that implements a specific aspect of the HTTP
        protocol. Usually protocol interceptors are expected to act upon one specific header or a
        group of related headers of the incoming message or populate the outgoing message with one
        specific header or a group of related headers. Protocol interceptors can also manipulate
        content entities enclosed with messages; transparent content compression / decompression
        being a good example. Usually this is accomplished by using the 'Decorator' pattern where
        a wrapper entity class is used to decorate the original entity. Several protocol
        interceptors can be combined to form one logical unit.
        </p>
        <p>
        HTTP protocol processor is a collection of protocol interceptors that implements the
        'Chain of Responsibility' pattern, where each individual protocol interceptor is expected
        to work on the particular aspect of the HTTP protocol it is responsible for.
        </p>
        <p>
        Usually the order in which interceptors are executed should not matter as long as they do
        not depend on a particular state of the execution context. If protocol interceptors have
        interdependencies and therefore must be executed in a particular order, they should be
        added to the protocol processor in the same sequence as their expected execution order.
        </p>
        <p>
        Protocol interceptors must be implemented as thread-safe. Similarly to servlets, protocol
        interceptors should not use instance variables unless access to those variables is
        synchronized.
        </p>
        <div class="section" title="1.2.1.&nbsp;Standard protocol interceptors"><div class="titlepage"><div><div><h3 class="title"><a name="d5e234"></a>1.2.1.&nbsp;Standard protocol interceptors</h3></div></div></div>
            
            <p>
            HttpCore comes with a number of most essential protocol interceptors for client and
            server HTTP processing.
            </p>
            <div class="section" title="1.2.1.1.&nbsp;RequestContent"><div class="titlepage"><div><div><h4 class="title"><a name="d5e237"></a>1.2.1.1.&nbsp;<code class="classname">RequestContent</code></h4></div></div></div>
                
                <p>
                <code class="classname">RequestContent</code> is the most important interceptor for
                outgoing requests. It is responsible for delimiting content length by adding
                the <code class="literal">Content-Length</code> or <code class="literal">Transfer-Content</code> headers
                based on the properties of the enclosed entity and the protocol version. This
                interceptor is required for correct functioning of client side protocol processors.
                </p>
            </div>
            <div class="section" title="1.2.1.2.&nbsp;ResponseContent"><div class="titlepage"><div><div><h4 class="title"><a name="d5e244"></a>1.2.1.2.&nbsp;<code class="classname">ResponseContent</code></h4></div></div></div>
                
                <p>
                <code class="classname">ResponseContent</code> is the most important interceptor for
                outgoing responses. It is responsible for delimiting content length by adding
                <code class="literal">Content-Length</code> or <code class="literal">Transfer-Content</code> headers
                based on the properties of the enclosed entity and the protocol version. This
                interceptor is required for correct functioning of server side protocol processors.
                </p>
            </div>
            <div class="section" title="1.2.1.3.&nbsp;RequestConnControl"><div class="titlepage"><div><div><h4 class="title"><a name="d5e251"></a>1.2.1.3.&nbsp;<code class="classname">RequestConnControl</code></h4></div></div></div>
                
                <p>
                <code class="classname">RequestConnControl</code> is responsible for adding the
                <code class="literal">Connection</code> header to the outgoing requests, which is essential
                for managing persistence of <code class="literal">HTTP/1.0</code> connections. This
                interceptor is recommended for client side protocol processors.
                </p>
            </div>
            <div class="section" title="1.2.1.4.&nbsp;ResponseConnControl"><div class="titlepage"><div><div><h4 class="title"><a name="d5e258"></a>1.2.1.4.&nbsp;<code class="classname">ResponseConnControl</code></h4></div></div></div>
                
                <p>
                <code class="classname">ResponseConnControl</code> is responsible for adding
                the <code class="literal">Connection</code> header to the outgoing responses, which is essential
                for managing persistence of <code class="literal">HTTP/1.0</code> connections. This
                interceptor is recommended for server side protocol processors.
                </p>
            </div>
            <div class="section" title="1.2.1.5.&nbsp;RequestDate"><div class="titlepage"><div><div><h4 class="title"><a name="d5e265"></a>1.2.1.5.&nbsp;<code class="classname">RequestDate</code></h4></div></div></div>
                
                <p>
                <code class="classname">RequestDate</code> is responsible for adding the
                <code class="literal">Date</code> header to the outgoing requests. This interceptor is
                optional for client side protocol processors.
                </p>
            </div>
            <div class="section" title="1.2.1.6.&nbsp;ResponseDate"><div class="titlepage"><div><div><h4 class="title"><a name="d5e271"></a>1.2.1.6.&nbsp;<code class="classname">ResponseDate</code></h4></div></div></div>
                
                <p>
                <code class="classname">ResponseDate</code> is responsible for adding the
                <code class="literal">Date</code> header to the outgoing responses. This interceptor is
                recommended for server side protocol processors.
                </p>
            </div>
            <div class="section" title="1.2.1.7.&nbsp;RequestExpectContinue"><div class="titlepage"><div><div><h4 class="title"><a name="d5e277"></a>1.2.1.7.&nbsp;<code class="classname">RequestExpectContinue</code></h4></div></div></div>
                
                <p>
                <code class="classname">RequestExpectContinue</code> is responsible for enabling the
                'expect-continue' handshake by adding the <code class="literal">Expect</code> header. This
                interceptor is recommended for client side protocol processors.
                </p>
            </div>
            <div class="section" title="1.2.1.8.&nbsp;RequestTargetHost"><div class="titlepage"><div><div><h4 class="title"><a name="d5e283"></a>1.2.1.8.&nbsp;<code class="classname">RequestTargetHost</code></h4></div></div></div>
                
                <p>
                <code class="classname">RequestTargetHost</code> is responsible for adding the
                <code class="literal">Host</code> header. This interceptor is required for client side
                protocol processors.
                </p>
            </div>
            <div class="section" title="1.2.1.9.&nbsp;RequestUserAgent"><div class="titlepage"><div><div><h4 class="title"><a name="d5e289"></a>1.2.1.9.&nbsp;<code class="classname">RequestUserAgent</code></h4></div></div></div>
                
                <p>
                <code class="classname">RequestUserAgent</code> is responsible for adding the
                <code class="literal">User-Agent</code> header. This interceptor is recommended for client
                side protocol processors.
                </p>
            </div>
            <div class="section" title="1.2.1.10.&nbsp;ResponseServer"><div class="titlepage"><div><div><h4 class="title"><a name="d5e295"></a>1.2.1.10.&nbsp;<code class="classname">ResponseServer</code></h4></div></div></div>
                
                <p>
                <code class="classname">ResponseServer</code> is responsible for adding the
                <code class="literal">Server</code> header. This interceptor is recommended for server side
                protocol processors.
                </p>
            </div>
        </div>
        <div class="section" title="1.2.2.&nbsp;Working with protocol processors"><div class="titlepage"><div><div><h3 class="title"><a name="d5e301"></a>1.2.2.&nbsp;Working with protocol processors</h3></div></div></div>
            
            <p>
            Usually HTTP protocol processors are used to pre-process incoming messages prior to
            executing application specific processing logic and to post-process outgoing messages.
            </p>
            <pre class="programlisting">
HttpProcessor httpproc = HttpProcessorBuilder.create()
        // Required protocol interceptors
        .add(new RequestContent())
        .add(new RequestTargetHost())
        // Recommended protocol interceptors
        .add(new RequestConnControl())
        .add(new RequestUserAgent("MyAgent-HTTP/1.1"))
        // Optional protocol interceptors
        .add(new RequestExpectContinue(true))
        .build();

HttpCoreContext context = HttpCoreContext.create();
HttpRequest request = new BasicHttpRequest("GET", "/");
httpproc.process(request, context);
</pre>
            <p>
            Send the request to the target host and get a response.
            </p>
            <pre class="programlisting">
HttpResponse = &lt;...&gt;
httpproc.process(response, context);
</pre>
            <p>
            Please note the <code class="classname">BasicHttpProcessor</code> class does not synchronize
            access to its internal structures and therefore may not be thread-safe.
            </p>
        </div>
    </div>
    <div class="section" title="1.3.&nbsp;HTTP execution context"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e309"></a>1.3.&nbsp;HTTP execution context</h2></div></div></div>
        
        <p>Originally HTTP has been designed as a stateless, response-request oriented protocol.
            However, real world applications often need to be able to persist state information
            through several logically related request-response exchanges. In order to enable
            applications to maintain a processing state HttpCpre allows HTTP messages to be
            executed within a particular execution context, referred to as HTTP context. Multiple
            logically related messages can participate in a logical session if the same context is
            reused between consecutive requests. HTTP context functions similarly to
            a  <code class="interfacename">java.util.Map&lt;String, Object&gt;</code>. It is
            simply a collection of logically related named values.</p>
        <p>Please nore <code class="interfacename">HttpContext</code> can contain arbitrary objects
            and therefore may be unsafe to share between multiple threads. Care must be taken
            to ensure that <code class="interfacename">HttpContext</code> instances can be 
            accessed by one thread at a time.</p>
        <div class="section" title="1.3.1.&nbsp;Context sharing"><div class="titlepage"><div><div><h3 class="title"><a name="d5e316"></a>1.3.1.&nbsp;Context sharing</h3></div></div></div>
            
            <p>
            Protocol interceptors can collaborate by sharing information - such as a processing
            state - through an HTTP execution context. HTTP context is a structure that can be
            used to map an attribute name to an attribute value. Internally HTTP context
            implementations are usually backed by a <code class="classname">HashMap</code>. The primary
            purpose of the HTTP context is to facilitate information sharing among various
            logically related components. HTTP context can be used to store a processing state for
            one message or several consecutive messages. Multiple logically related messages can
            participate in a logical session if the same context is reused between consecutive
            messages.
            </p>
            <pre class="programlisting">
HttpProcessor httpproc = HttpProcessorBuilder.create()
        .add(new HttpRequestInterceptor() {
            public void process(
                    HttpRequest request,
                    HttpContext context) throws HttpException, IOException {
                String id = (String) context.getAttribute("session-id");
                if (id != null) {
                    request.addHeader("Session-ID", id);
                }
            }
        })
        .build();

HttpCoreContext context = HttpCoreContext.create();
HttpRequest request = new BasicHttpRequest("GET", "/");
httpproc.process(request, context);
</pre>
        </div>
    </div>
</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="preface.html">Prev</a>&nbsp;</td><td width="20%" align="center">&nbsp;</td><td width="40%" align="right">&nbsp;<a accesskey="n" href="blocking-io.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Preface&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;2.&nbsp;Blocking I/O model</td></tr></table></div></body></html>